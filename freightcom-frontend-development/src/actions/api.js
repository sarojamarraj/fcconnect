import { CALL_API } from 'redux-api-middleware';
import { normalize, arrayOf } from 'normalizr';
import { camelize, camelizeKeys, pascalize } from 'humps';
import merge from 'lodash/merge';
import { v4 } from 'uuid';

import { buildURL } from '../utils';

import Schemas from '../schemas';

export const API_GET_ALL_REQUEST = 'API_GET_ALL_REQUEST';
export const API_GET_ALL_SUCCESS = 'API_GET_ALL_SUCCESS';
export const API_GET_ALL_FAILURE = 'API_GET_ALL_FAILURE';

export const API_GET_ONE_REQUEST = 'API_GET_ONE_REQUEST';
export const API_GET_ONE_SUCCESS = 'API_GET_ONE_SUCCESS';
export const API_GET_ONE_FAILURE = 'API_GET_ONE_FAILURE';

export const API_SAVE_REQUEST = 'API_SAVE_REQUEST';
export const API_SAVE_SUCCESS = 'API_SAVE_SUCCESS';
export const API_SAVE_FAILURE = 'API_SAVE_FAILURE';

export const API_POST_REQUEST = 'API_POST_REQUEST';
export const API_POST_SUCCESS = 'API_POST_SUCCESS';
export const API_POST_FAILURE = 'API_POST_FAILURE';

export const API_UPDATE_REQUEST = 'API_UPDATE_REQUEST';
export const API_UPDATE_SUCCESS = 'API_UPDATE_SUCCESS';
export const API_UPDATE_FAILURE = 'API_UPDATE_FAILURE';

export const API_SEARCH_REQUEST = 'API_SEARCH_REQUEST';
export const API_SEARCH_SUCCESS = 'API_SEARCH_SUCCESS';
export const API_SEARCH_FAILURE = 'API_SEARCH_FAILURE';

export const API_DELETE_REQUEST = 'API_DELETE_REQUEST';
export const API_DELETE_SUCCESS = 'API_DELETE_SUCCESS';
export const API_DELETE_FAILURE = 'API_DELETE_FAILURE';

/**
 * Getting an array of objects from server.
 * Results will be processed by normalizr and store results to `entities` and
 * `pagination` for meta data in the redux store
 *
 * @param entity { String } keyword for the redux store entities.[entity]
 *        this should be the same as the key name in the schema
 * @param schema { normalizr.Schema } This should be a schema generated by normalizr
 * @param pageToLoad { Number } to be passed as query string
 * @param itemsPerPage { Number }
 * @param filters { Object } Should be object of key-value pairs for filtering
 * @param sortOrder { Object } Should contain `sortBy` and `order: ASC|DESC` property
 * @param endpoint { String } If endpoint differs from `entity`. `/api/` is prepended
 * @param entityMap { String } For the JSON response that differs from `entity`
 */
export const getAll = (
  entity,
  schema,
  pageToLoad = 1,
  itemsPerPage = 10,
  filters = {},
  sortOrder = { sortBy: 'id', order: 'DESC' },
  endpoint = false,
  entityMap = false,
  redirectPath = false,
  meta = {},
) => ({
  [CALL_API]: {
    credentials: 'include',
    endpoint: buildURL(
      '/api/' + (endpoint ? endpoint : entity),
      pageToLoad,
      itemsPerPage,
      filters,
      sortOrder,
    ),
    method: 'GET',
    types: [
      { type: API_GET_ALL_REQUEST, meta: { entity: camelize(entity) } },
      {
        type: API_GET_ALL_SUCCESS,
        meta: { ...meta, entity: camelize(entity) },
        payload: (action, state, response) => {
          const contentType = response.headers.get('Content-Type');
          if (contentType && ~contentType.indexOf('json')) {
            return response.json().then(json => {
              const embedded = entityMap ? entityMap : entity;

              if (json._content && json.page) {
                return merge(
                  camelizeKeys(normalize(json._content || [], arrayOf(schema))),
                  {
                    currentPage: pageToLoad,
                    totalItems: json.page.totalElements,
                    itemsPerPage,
                    filters,
                    sortOrder,
                  },
                );
              } else if (json._embedded || json._links) {
                return merge(
                  camelizeKeys(
                    normalize(json._embedded[embedded] || [], arrayOf(schema)),
                  ),
                  {
                    currentPage: pageToLoad,
                    totalItems: json.page.totalElements,
                    itemsPerPage,
                    filters,
                    sortOrder,
                  },
                );
              } else {
                return merge(camelizeKeys(normalize(json, arrayOf(schema))), {
                  currentPage: pageToLoad,
                  totalItems: json.length,
                  itemsPerPage,
                  filters,
                  sortOrder,
                });
              }
            });
          }
        },
      },
      {
        type: API_GET_ALL_FAILURE,
        meta: { redirectPath: redirectPath, entity: camelize(entity) },
      },
    ],
  },
});

/**
 * Don't use this...
 */
const entityMap = {
  order: 'customerOrders',
  address_book: 'addressBooks',
  'customer-staff': 'user',
};

/**
 * TODO: Figure out a better and more flexible implementation...
 * NOTE: Still being used in order logged events
 */
export const getAllOptions = options => {
  const {
    entity,
    schema,
    pageToLoad = 1,
    itemsPerPage = 10,
    filters = {},
    sortOrder = {},
    redrawIfFetching = true,
    searchMethod,
    overrideUrl,
  } = options;

  let url = overrideUrl ? overrideUrl : `/api/${entity}`;

  if (searchMethod) {
    url += `/search/${searchMethod}`;
  }
  return {
    [CALL_API]: {
      credentials: 'include',
      endpoint: buildURL(url, pageToLoad, itemsPerPage, filters, sortOrder),
      method: 'GET',
      types: [
        {
          type: API_GET_ALL_REQUEST,
          meta: { entity: camelize(entity), redrawIfFetching },
        },
        {
          type: API_GET_ALL_SUCCESS,
          meta: { entity: camelize(entity), redrawIfFetching },
          payload: (action, state, response) => {
            const contentType = response.headers.get('Content-Type');

            if (contentType && contentType.indexOf('json') >= 0) {
              return response.json().then(json => {
                const embedded = entityMap[entity] ? entityMap[entity] : entity;
                const result = json._embedded || json._links
                  ? merge(
                      camelizeKeys(
                        normalize(
                          json._embedded[embedded] || [],
                          arrayOf(schema),
                        ),
                      ),
                      {
                        currentPage: pageToLoad,
                        totalItems: json.page.totalElements,
                        itemsPerPage,
                        filters,
                        sortOrder,
                        redrawIfFetching,
                        qqq: 'yyy',
                      },
                    )
                  : merge(camelizeKeys(normalize(json, arrayOf(schema))), {
                      currentPage: pageToLoad,
                      totalItems: json.length,
                      itemsPerPage,
                      filters,
                      sortOrder,
                      redrawIfFetching,
                    });
                return result;
              });
            }
          },
        },
        { type: API_GET_ALL_FAILURE, meta: { entity: camelize(entity) } },
      ],
    },
  };
};

/**
 * Getting a single object from server
 *
 * NOTE:  The result here should also be normalized like
 *        `getAll`. Right now we're not passing any schema...
 *        Either pass the first parameter as schema or
 *        Have a schema map lookup to only pass strings
 */
export const getOne = (
  entity,
  id,
  entityMap = false,
  endpoint = false,
  callbackAction = false,
  redirectPath = false,
  meta = {},
) => ({
  [CALL_API]: {
    credentials: 'include',
    endpoint: endpoint ? `/api/${endpoint}` : `/api/${entity}/${id}`,
    method: meta.method || 'GET',
    types: [
      {
        type: API_GET_ONE_REQUEST,
        meta: { entity: camelize(entity), id: id, ...meta },
      },
      {
        type: API_GET_ONE_SUCCESS,
        meta: { entity: camelize(entity), id: id, ...meta },
        payload: (action, state, response) => {
          const contentType = response.headers.get('Content-Type');

          if (contentType && ~contentType.indexOf('json')) {
            return response.json().then(json => {
              if (typeof callbackAction === 'function') {
                callbackAction(json);
              }
              const id = json.id;
              const schema = Schemas[pascalize(entity) + 'Schema'];
              if (schema) {
                return camelizeKeys(normalize(json, schema));
              } else {
                return { id, entity: camelizeKeys(json) };
              }
            });
          }
        },
      },
      {
        type: API_GET_ONE_FAILURE,
        meta: {
          redirectPath: redirectPath,
          entity: camelize(entity),
          id: id,
          ...meta,
        },
      },
    ],
  },
});

/**
 * Saving data to the server. For creating new data
 */
export const save = (
  entity,
  data,
  route = false,
  key = 'save',
  method = 'POST',
  callbackAction = false,
  redirectPath = false,
) => ({
  [CALL_API]: {
    credentials: 'include',
    endpoint: route ? `/api/${route}` : `/api/${entity}`,
    method: method,
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
    types: [
      API_SAVE_REQUEST,
      {
        type: API_SAVE_SUCCESS,
        meta: { entity: camelize(entity) },
        payload: (action, state, response) => {
          const contentType = response.headers.get('Content-Type');

          if (contentType && ~contentType.indexOf('json')) {
            return response.json().then(json => {
              if (typeof callbackAction === 'function') {
                callbackAction(json);
              }
              const id = json.id;
              const schema = Schemas[pascalize(entity) + 'Schema'];
              if (schema) {
                return { id, ...camelizeKeys(normalize(json, schema)) };
              } else {
                return { id, entity: camelizeKeys(json) };
              }
            });
          } else {
            return { response: response };
          }
        },
      },
      {
        type: API_SAVE_FAILURE,
        meta: { redirectPath: redirectPath, entity: camelize(entity) },
        payload: (action, state, response) => {
          const contentType = response.headers.get('Content-Type');
          if (contentType && ~contentType.indexOf('json')) {
            return response.json().then(json => {
              if (typeof callbackAction === 'function') {
                callbackAction(json);
              }
              return json;
            });
          } else {
            return { response: response };
          }
        },
      },
    ],
  },
});

const ifNotObject = (object, defaultValue = {}) =>
  object === Object(object) ? object : defaultValue;

/**
 * Updating values on existing data in the server
 */
export const update = (
  entity,
  id,
  data,
  route = false,
  meta = {},
  method = 'PUT',
  callbackAction = false,
  redirectPath = false,
) => ({
  [CALL_API]: {
    credentials: 'include',
    endpoint: route ? `/api/${route}` : `/api/${entity}/${id}`,
    method: method,
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
    types: [
      API_SAVE_REQUEST,
      {
        type: API_SAVE_SUCCESS,
        meta: { ...ifNotObject(meta), entity: camelize(entity) },
        payload: (action, state, response) => {
          const contentType = response.headers.get('Content-Type');

          if (contentType && ~contentType.indexOf('json')) {
            return response.json().then(json => {
              if (typeof callbackAction === 'function') {
                callbackAction(json);
              }
              const schema = Schemas[pascalize(entity) + 'Schema'];
              if (schema) {
                return { id, ...camelizeKeys(normalize(json, schema)) };
              } else {
                return { id, entity: camelizeKeys(json) };
              }
            });
          } else {
            return { response: response };
          }
        },
      },
      {
        type: API_SAVE_FAILURE,
        meta: {
          ...ifNotObject(meta),
          redirectPath: redirectPath,
          entity: camelize(entity),
        },
      },
    ],
  },
});

export const deleteEntity = (entity, entityId, options = {}) => {
  const {
    endpoint = `/${entity}/${entityId}`,
    onSuccessCallback = () => {},
    onFailureCallback = () => {},
  } = options;

  return {
    [CALL_API]: {
      credentials: 'include',
      endpoint: `/api/${endpoint}`,
      method: 'DELETE',
      types: [
        API_DELETE_REQUEST,
        {
          type: API_DELETE_SUCCESS,
          payload: (action, state, response) => {
            onSuccessCallback();
            return {};
          },
        },
        {
          type: API_DELETE_FAILURE,
          payload: (action, state, response) => {
            onFailureCallback();
            response.json().then(json => {
              return json;
            });
          },
        },
      ],
    },
  };
};

/**
 * Currently being used by autoSuggest functionality in addressbook
 */
export const search = (entity, schema, keyword, meta = {}) => {
  const requestId = v4();

  return {
    [CALL_API]: {
      credentials: 'include',
      endpoint: entity === 'address_book'
        ? `api/${entity}?q=${keyword}&page=0&size=20&sort=consigneeName,asc` +
            (meta && meta.customer && meta.customer.id
              ? `&customer_id=${meta.customer.id}`
              : '')
        : `/api/customer/search/findByNameContainingAllIgnoringCase?name=${keyword}`,
      method: 'GET',
      types: [
        {
          type: API_SEARCH_REQUEST,
          meta: Object.assign({ entity: camelize(entity) }, meta),
          payload: { requestId },
        },
        {
          type: API_SEARCH_SUCCESS,
          meta: Object.assign({ entity: camelize(entity) }, meta),
          payload: (action, state, response) => {
            const contentType = response.headers.get('Content-Type');
            const totalItems = response.headers.get('X-Total-Count');
            if (contentType && ~contentType.indexOf('json')) {
              return response.json().then(json => {
                if (json._embedded || json._links) {
                  const embedded = entityMap[entity]
                    ? entityMap[entity]
                    : entity;
                  return merge(
                    camelizeKeys(
                      normalize(
                        json._embedded[embedded] || [],
                        arrayOf(schema),
                      ),
                    ),
                    { keyword, totalItems: json.page.totalElements, requestId },
                  );
                } else {
                  return merge(camelizeKeys(normalize(json, arrayOf(schema))), {
                    keyword,
                    totalItems,
                    requestId,
                  });
                }
              });
            }
          },
        },
        {
          type: API_SEARCH_FAILURE,
          meta: Object.assign({ entity: camelize(entity) }, meta),
        },
      ],
    },
  };
};
